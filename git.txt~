хранит слепки вместо патчей

Три состояния
В Git'е файлы могут находиться в одном из трёх состояний: зафиксированном, изменённом и подготовленном. "Зафиксированный" значит, что файл уже сохранён в вашей локальной базе. К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы. Подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.
Таким образом, в проектах, использующих Git, есть три части: каталог Git'а (Git directory), рабочий каталог (working directory) и область подготовленных файлов (staging area).

git config
Файл /etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
Файл ~/.gitconfig хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global.
Конфигурационный файл в каталоге Git'а (.git/config) в том репозитории, где вы находитесь в данный момент. Эти параметры действуют только для данного конкретного репозитория. Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.

git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
git config --global core.editor mcedit

git config --list - список настроек

man git config - вывести справку по конкретной команде


git init - создать репозиторий в текущем каталоге

git add *.c - проиндексировать файлы *.c
git add README - проиндексировать файл README
git commit -m 'initial project version' - закомитить внесенное в индекс с комментарием initial project version

git clone git://github.com/schacon/grit.git mygrit - клонирование репозитория в папку mygrit

git status - вывод состояния файлов

.gitignore - список игнорируемых файлов (шаблонов файлов)
К шаблонам в файле .gitignore применяются следующие правила:
Пустые строки, а также строки, начинающиеся с #, игнорируются.
Можно использовать стандартные glob шаблоны.
Можно заканчивать шаблон символом слэша (/) для указания каталога.
Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.

cat .gitignore 
*.[oa]
*~

пример выбирать только sql и bsh файлы в любых подкаталогах
*
!**/
!**/*.sql
!**/*.bsh



git diff - Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.
git diff --cached - аналогично, но уже проиндексированное (синоним git diff --staged)

git commit - фиксирование изменений

Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add

git log -p -2 - история комитов с выводом разницы и только последние 2 комита
git log --stat выведет дополнительную статистику
git log --pretty=oneline - выведет каждый комит в отдельной строке
git log --pretty=format:"%h - %an, %ar : %s" - свой формат вывода
%H	Хеш коммита
%h	Сокращённый хеш коммита
%T	Хеш дерева
%t	Сокращённый хеш дерева
%P	Хеши родительских коммитов
%p	Сокращённые хеши родительских коммитов
%an	Имя автора
%ae	Электронная почта автора
%ad	Дата автора (формат соответствует параметру --date=)
%ar	Дата автора, относительная (пр. "2 мес. назад")
%cn	Имя коммитера
%ce	Электронная почта коммитера
%cd	Дата коммитера
%cr	Дата коммитера, относительная
%s	Комментарий

git log --since=2.weeks - выведет комиты за последние 2 недели

git log -- rglMan/getJSON.php - выведет комиты по указанному файлу

git commit --amend - запишется поверх последнего комита

git checkout -- benchmarks.rb - отменит изменения в файле benchmarks.rb сделанные с момента последнего комита

git remote - она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов
origin — это имя по умолчанию, которое Git присваивает серверу, с которого вы склонировали
git remote -v - дополнительно выведет url

remote add [сокращение] [url]
 git remote add pb git://github.com/paulboone/ticgit.git
 
 git remote rename pb paul - переименует ветку pb в paul

 git remote rm paul - удалит ссылку на удаленный сервер paul
 
git push [удал. сервер] [ветка]
 git push origin master
 
git tag - выводит метки
git tag -l 'v1.4.2.*' - выведет метки по шаблону
git tag -a v1.4 -m 'my version 1.4' - создаст аннотированную метку v1.4 с комментарием my version 1.4
git tag -a v1.2 -m 'version 1.2' 9fceb02 - пометит выбранный комит в истории

git tag v1.4-lw - создать легковесную метку (простой спобос пометить комит без всякой доп. информации)

git push origin --tags - отправит все метки на сервер (поумолчанию они не отправляются)


git branch hotfix - создаст ветку hotfix
git checkout hotfix - перейдет на ветку hotfix

git checkout s3jsfk - перейдет на указанынй комит 

можно сразу git checkout -b hotfix - создаст и перейдет

git checkout master
git merge hotfix
git branch -d hotfix - удалит ветку
если в ней есть незакомиченные доработки использовать git branch -D hotfix

git branch - список веток
git branch -v - список веток с последним комитом

Как отменить последний коммит?
Можно использовать git reset, вот так:
git reset --hard HEAD~1
HEAD~1 означает один коммит до HEAD т.е. до текущего положения. Стоит заметить, что это «ядерный» способ, который отменит все изменения. Если вам нужно сохранить всё, что вы сделали, но еще не успели закоммитить, используйте:
git reset --soft HEAD~1

Удалить ветку на сервере
git push origin --delete имя_ветки

Вернуться к любому коммиту
Можно использовать reset, как показано ранее, но это будет означать, что вы хотите навсегда вернуться к тому состоянию, в котором вы были, а не просто посмотреть на него (для этого надо сделать checkout). Идентификатор коммита должен быть такой, как он прописан в выводе команды git log.
git reset --hard идентификатор_коммита
Еще раз повторим, что это отменит все текущие изменения, так что убедитесь, что это действительно то, что вам нужно. Или используйте --soft вместо --hard.


Восстановить удалённый файл
Сначала нужно найти последний коммит, где файл еще существовал:
git rev-list -n 1 HEAD -- имя_файла
Потом восстановить этот файл:
git checkout найденный_коммит^ -- имя_файла
Вернуть один конкретный файл на состояние, в котором он был в каком-либо коммите
Примерно как в прошлом примере, только чуть проще:
git checkout идентификатор_коммита имя_файла
 
$ git checkout master~5 - запросить 5-ое с конца сохраненное состояние:


git reset — возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий»
git reset - сбросить весь индекс

«Мягкий» (с ключом --soft) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:
git commit — некорректный коммит
git reset --soft HEAD^ — переходим к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы
edit WRONGFILE
edit ANOTHERWRONGFILE
git add .
git commit -c ORIG_HEAD — вернуться к последнему коммиту, будет предложено редактировать его сообщение. Если сообщение оставить прежним, то достаточно изменить регистр ключа -с:
git commit -C ORIG_HEAD



«Жесткий» резет (ключ --hard) — команда, которую следует использовать с
осторожностью. git reset --hard вернет дерево проекта и индекс в состояние,
соответствующее указанному коммиту, удалив изменения последующих коммитов:
git add .
git commit -m «destined to death»
git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...
git reset --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!


git revert — отмена изменений, произведенных в прошлом отдельным коммитом (по тэгу или хэшу)


Показать изменения, не внесенные в индекс:
git diff


Посмотреть изменения, внесенные любым коммитом в истории, можно командой git show:
git show COMMIT_TAG



