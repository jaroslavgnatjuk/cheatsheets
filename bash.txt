список всех файлов с подпапками сортированно по дате
ls -lRt > sortedfile.list

поправить конфиг apt-get прокси
sudo -H gedit /etc/apt/apt.conf
And add Acquire::http::Proxy "http://username:password@proxyhost:port/";

ярлык
/usr/share/applications/
[Desktop Entry]
Name=
Comment=
GenericName=
Keywords=
Exec=
Terminal=false
Type=Application
Icon=
Path=
Categories=
NoDisplay=false

дата
date +%Y%m%d_%H%M%S - 20160404_161456


sudo fuser -k 80/tcp - кто держит порт (-k убьет эти процессы)

запускать гедит под рутом из терминала
alias geditx="gksudo env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY gedit"


копировать файлы по маске
for file in ~/Videos/**/*.JPG; do cp "$file" ~/Videos/; done

json=$(python2.7 data_types.py tcards.txt '|' 0); echo ${json//\'/\"} - выгружаем результат выполнения команды в переменную, заменяем одинарные кавычки на двойные
echo ${original_string//find/replace} - контекстная замена

впн с винды на убунту
для того что-бы использовать rdp
на линуксе ставим xrdp и mate-desktop http://wiki.mate-desktop.org/download
создаем в хоум директории файл .xsession и заносим в него строку mate-session
рестартуем xrdp командой sudo service xrdp restart
всё!

PPA repository behind proxy problem:
http://thelittleican.blogspot.in/2013/09/unable-to-add-ppa-behind-proxy.html


ls | grep -v .git | xargs rm -r - удалить все файлы кроме .git


top -p $(pgrep -d',' python) - выводит инфу по пидам команды python


- пройдется построчно по файлу, выведет в каждую строку к-во встречаний запятой, отсортирует и выберет уникальные
for line in $(cat ./Data_for_PB_appl_model.csv)
do

echo $(grep -o "," <<< "$line" | wc -l) >> file

done

sort file | uniq
rm file



- показывать напоминалку каждые N минут с определнным сообщением + проверка висит ли уже такое сообщение

10,40 * * * * if [ $(ps -ef | grep Напоминалка | wc -l) -eq 1 ]; then export DISPLAY=:0 && zenity --info --title="Напоминалка" --text="Пора размяться!" --display=:0.0; fi



варианты как кильнуть все процессы dbisql:
1)
for pid in $(ps -o pid h -C java)
do
dbisql=$(ps -p $pid -o command | grep dbisql)

if [[ "$dbisql" != "" ]]; then
		kill $pid
fi

done

2) pkill -f dbisql

3) kill `ps -ef | grep d[b]isql | awk '{print $2}'`

вывести домашний каталог юзера:

if [ -z $1 ]; then
	echo must enter user name
	exit 1
fi

echo $(sed -n '/^'$1'/p' /etc/passwd | awk -F: '{print $6}')

или $(grep '^'$1'' /etc/passwd | cut -d: -f6)

вывести топ 5 процессов по потреблению памяти

ps -eo pid,size | sort -grk 2 | head -n 5
ps -e все процессы, -o указать поля
sort -g сортировка чисел, -r обратном порядке, -k указать поле

Написать скрипт, который выведет всех потомков процесса по его PID

ps -eo pid,ppid | grep 24805 | cut -d" " -f1
или ps --ppid=${pid}





/etc/bash.bashrc - общий для всех файл загрузки (в нем часто бывают переменные среды)
в переменных PS1 и PS2 содержится формат приглашения к вводу в терминале
$LS_COLORS - цвета различных типов файлов при выводе в терминал с помощью ls
ls -lhS l-long, h - hunamreadable S sort-size X sorx extension
tail -f -s 10 file.txt показывать конец файла с обновлением в 10сек
ps -f -U yarik --forest показывает широкую информацию о процессах юзера yarik и показывает иерархию процессов
top shift > < для смены поля сортировки, x для выделения поля сортировки
du -hd 1 или du --max-depth=1 -h | sort -hr показать занимаемое пространство всех подпапок в папке без под директорий и отсортирует по убыванию
du -d 1 | sort -n сортирует по числам размер подпапок
PATH=$PATH:/home/user/test добавили новый путь к переменной
PATH=$PATH:. добавили текущий каталог к переменной

массивы:
arr=(a1 s2 s3)
arr[1]=x5
echo ${arr[1]}
echo ${arr[*]}
unset arr[2]
unset arr

alias li='ls -il' создание псеводнима

useradd - добавление нового юзера
userdel - удаление юзера 
userdel -r - удаление юзера вместе с домашней папкой
usermod -g shared yarik заменяет группу юзера yarik по умолчанию а shared
usermod -G shared yarik добавляет к группе shared юзера yarik


today=`date +%y%m%d`
today2=$(date +%Y-%m-%d)

ssh sybase@rims.vm.pbank.com.ua - enter server by ssh
scp -r sybase@rims.vm.pbank.com.ua:/DATA/scripts ~/scripts - copy folder by ssh

wc < file1 перенаправление ввода из файла
wc << marker
test1
test2
test3
marker перенаправление ввода из буфера (в скрипте), если в ком.строке ввести wc << merker, то будет запрашивать ввод пользователя пока не введет marker


rpm -qa | sort | more - каналы

expr 1 + 3 - выводит (возвращает) 4 (если указаны операции сравнения возвращает 1 если истино и 0 если ложно)
для вычислений лучше использовать $[operation]
echo $[ 2 * (2 + 3)] - выведет 10. Позиции и к-во пробелов в скобках не важны в данном случае. Работает только с целыми числами.

для вычислений с плавающей точкой можно использовать калькулятор bc
echo "scale=4; 2/4" | bc вернет .5000
более сложные вычисления
var5=‛bc << EOF
scale = 4
a1 = ( $var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
‛

$? - статус последней выполненной команды (0 - успешно, >0 код ошибки)
exit 5 - выйдет из скрипта и вернет вызывающему код 5


if command
then
	commands
elif command2
	commands
else
	commands
fi
command - команда возвращающая 0 в случае успеха и >0 в случае неудачи (не так как обычно в языках программирования)

if grep $testuser /etc/passwd
then
echo The bash files for user $testuser are:
ls -a /home/$testuser/.b*
fi

test - часто используется в if, проверяет выражения и возвращает результат своего выполнения как команды
[ a -gt b ] тоже самое что test a -gt b
if test 5 -gt 2; then echo true; fi
тоже самое:
if [ 5 -gt 2 ]; then echo true; fi

составные условия:
[ condition1 ] && [ condition2 ]
[ condition1 ] || [ condition2 ]


двойные круглые скобки можно также использовать для математических вычислений
if (( $val1 ** 2 > 90 )); then ...

двойные квадратные скобки можно использовать для вычислений выражений со строками
if [[ $USER == r* ]]; then ...

команда case:
case variable in
pattern1 | pattern2) commands1;;
pattern3) commands2;;
*) default commands;;
esac


циклы:
for var in list
do
commands
done

пример:
for test in Nevada "New Hampshire" "New Mexico" "New York"
do
echo "Now going to $test"
done

IFS - переменная, которая содержит символы разделения полей по умолчанию
IFS=$'\n' - на время заменить на только конец строки
желательно после изменения этой переменной восстанавливать ее

пример (разбор по строкам и полям файл юзеров):
passwd=/etc/passwd
oldifs=$IFS
IFS=$'\n'
for item in $(cat $passwd)
do
	echo ! $item
IFS=:

for field in $item
do
	echo -n " !!!!: " $field
done
	
done
IFS=$oldifs


# итерации по всем файлам в каталоге
for file in /home/rich/.b* /home/rich/badtest
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done

"$file" - т.к. имена файлов могут содержать пробелы

for в стиле C:
for (( i=1; i <= 10; i++ ))
do
echo "The next number is $i"
done

while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done

until [ $var1 -eq 0 ]
do
echo $var1
var1=$[ $var1 - 25 ]
done

break
continue

break n, continue n
где n указывает уровень цикла, из которого должен быть выполнен выход. По умолчанию n
равно 1, а это означает, что выход должен быть выполнен из текущего цикла. Если будет задано
значение n, равное 2, то команда break остановит выполнение внешнего цикла следующего
уровня

перенаправление вывода в файл:
for file in /home/rich*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif
echo "$file is a file"
fi
done > output.txt

перенаправление в другую команду (sort):
for state in "North Dakota" Connecticut Illinois Alabama Tennessee
do
    echo "$state is the next place to go"
done | sort > myfile


переменные передаваемые в ком.строке:
$1, $2 .... $9
$0 - имя программы (весь текст, включая полный путь если он указан)
можно отделить имя программы от пути name=‛basename $0‛
если больше, то нужно ${10}, ${11} ...

пример проверки передана ли переменная:
if [ -n "$1" ]
then
echo Hello $1, glad to meet you.
else
echo "Sorry, you did not identify yourself. "
fi

$# содержит значение количества параметров командной строки

знак доллара нельзя исползьовать в фигурных скобках
чтобы получить последний параметр переданный скрипту нужно указывать восклицательный знак
${!#}
или
params=$#
echo The last parameter is $params

$* принимает все параметры, заданные в командной строке, как одно слово
$@ воспринимает все параметры, заданные в командной строке, как отдельные слова в одной и той же строке

for param in "$@"
do
echo "\$@ Parameter #$count = $param"
done

# демонстрация применения команды shift
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$[ $count + 1 ]
shift
done


# извлечение из командной строки опций и значений
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift 2;;
-c) echo "Found the -c option";;
--) shift
break;;
*) echo "$1 is not an option";;
esac
shift&
done

getopt, getopts - команды для представления введенных параметров в более читабельном виде для обработки скриптом

ввод данных пользователем в ходе выполнения программы:
echo -n "Enter your name: "
read name
или
read -p "Please enter your age: " age

ввод нескольких переменных через пробел:
read -p "Enter your name: " first last

так же ввод пользователя в любом случае сохраняется в пременную $REPLY

таймаут ожидания ввода пользователя:
опция -t

if read -t 5 -p "Please enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo
echo "Sorry, too slow! "
fi&

read -n - количество символов, которые ожидает команда read
например read -n1 будет ждать 1 символ без ожидания ввода

read -s - скрывает вводимые данные (например пароль)



# чтение данных из файла
count=1
cat test | while read line
do
echo "Line $count: $line"
count=$[ $count + 1]
done


Дескриптор файла Сокращение Описание
0 STDIN Стандартный ввод (обычно клавиатура)
1 STDOUT Стандартный вывод (обычно монитор)
2 STDERR Стандартный вывод сообщений об ошибках (обычно монитор)

> file перенаправляем вывод не на STDOUT, а в произвольный файл
< file аналогично перенаправляем ввод (из файла, а не клавиатуры)

для перенаправления STDERR можно указать дескриптор
2> file
&> file перенаправит и ошибки и стандартный вывод в файл

можно также перенаправить в стандартный поток свои сообщения
echo "This is an error" >&2
echo "This is normal output"

перенаправление для всего вывода скрипта можно сделать разово
exec 1>testout
exec 2>testerror

exec 3>&- закрытие дескриптора номер 3

для подавления вывода нужно перенаправлять его в файл null
ls -al > /dev/null
или для подавления потока ошибок
ls -al badfile test16 2> /dev/null

один из методов очистки файла
cat /dev/null > testfile

$$ - текущее значение PID процесса командного интерпретатора

временные файлы нужно создавать в /tmp
mktemp создает файл с уникальным именем в темповой папке
для создания темпового файла в локальном каталоге используется 
mktemp testing.XXXXXX, где XXX - любое к-во случайно сгенеренных символов
mktemp -t test.XXXXXX - создает файл по маске в темповом каталоге
mktemp -d dir.XXXXXX - для создания дирректорий

если нужно перенаправлять вывод и в файл и на экран то можно использовать такой "тройник", команда tee
date | tee -a testfile (-a значит не перезаписывать файл, а добавлять append)


перехват сигналов
trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT SIGTERM

перехват выхода из программы
trap "echo byebye" EXIT
удаление ловушки
trap - EXIT

./test1 & - выполнение в фоновом режиме

nohup ./test1 & - прерывает связь между программой и терминалом
т.е. даже после закрытия терминала программа будет работать (она игнорит сигнал SIGHUP (выход))
данные которые выводились бы на экран терминала, будут попадать в файл nohup.out

jobs - показывает запущенные задания в терминале
bg 2 - перезапускает задание 2 (задание будет выполняться на заднем плане)
fg 2 - перезапускает задание 2 (задание будет выполняться на переднем плане)

приоритет процесса
-20 (самый высокий приоритет) +19 (самый низкий приоритет)

nice -n 10 ./test4 > test4out & - запустит процесс с пониженным приоритетом с выводом в test4out  в фоновом режиме
обычный пользователь не может повысить приоритет, только понизить
renice 10 -p 29504 - изменяет приоритет процесса уже работающего (pid 29504)

планирование заданий
команда at устанавливает отложенное задание
демон atd выполняет его
список заданий хранится в /var/spool/at
atq показывает список заданий в очереди
atrm удаление задания


cron
пример выполнения в последний день месяца
00 12 * * * if ['date +%d -d tomorrow' = 01 ] ; then ; command

crontab -e создает таблицу расписания или открывает для редактирования, если она уже есть
crontab -l показывает ее на экран

Применяются четыре основных каталога для определения времени выполнения
в часах, днях, месяцах и неделях: hourly, daily, monthly и weekly
можно просто закинуть свой сценарий в один из каталогов не редактируя таблицу расписания

anacron предназначена для выполнения сценариев, которые не были выполнены cron, например, по причине выключенного компьютера
таблица anacron находится по адресу etc/anacrontab


Процесс начальной загрузки
После включения системы Linux в оперативную память компьютера загружается и вызыва-
ется на выполнение ядро Linux. Прежде всего в ядре осуществляется запуск процесса init типа
UNIX System V или процесс init типа Upstart, в зависимости от применяемого дистрибутива
и его версии. Затем этот процесс берет на себя ответственность за запуск всех прочих процес-
сов в системе Linux.

сценарии запуска находятся в /etc/init.d

/etc/rc.local - локальный файл запуска, предназначенный именно для того, чтобы системный ад-
министратор мог вводить сценарии для запуска во время начальной загрузки

в домашней папке пользователя есть файлы для автоматического запуска сценариев
.bash_profile - при регистрации пользователя в системе
.bashrc - при каждом начале работы с командным интерпретатором

/etc/bashrc - аналогично, но для всех пользователей


функции

function name {
commands
}

или

name() {
commands
}

return может возвращать целое число от 0 до 256

получить его значение можно через переменную $? (по сути return в данном случае просто последняя выполненная команда)
вернуть вывод текста из функции можно аналогично любой другой команде v=`func`
передать параметры в функцию можно аналогично параметрам сценария т.е. при вызове функции через пробел
перечислить параметры и считать внутри функции с помощью переменных среды $1 .. $9 $# и т.п.

локальные переменные:
local temp=$[ $value + 5 ]

подключать файл с нужными функциями и переменными (библиотеку) можно так:
source filename [arguments]
или
. filename [arguments]

--sed---------------------------------------------------------------------------------------------------------------------

sed - потоковый текстовый редактор
echo "This is a test" | sed 's/test/big test/'
This is a big test

sed 's/dog/cat/' file1

если нужно более одной команды, то использовать флаг -e
sed -e 's/brown/green/; s/dog/cat/' file1

для большого к-ва команд лучше их сохранить в файл
sed -f script1 file1

подстановка
s/pattern/replacement/flags

flags - (
	число-номер вхождения паттерна который заменять, 
	g-заменять все, 
	p-вывести содержимое исходной строки, (sed -n 's/test/trial/p' data5 вместе с флагом -n, который подавляет вывод sed, 
											выводит только строки которые были изменены)
	w file-запись результата подстановки в файл (только строки в которых сработала подстановка))
	
можно задать свой экранирующий символ (в данном примере !)	
sed 's!/bin/bash!/bin/csh!' /etc/passwd	

указание строк, к которым применять подстановку
sed '2,4s/dog/cat/' data1 - будет применяться в диапазоне от 2 до 4 строки
если указать $ как конец диапазона это означает до конца файла

sed '/Samantha/s/bash/csh/' /etc/passwd - обработка только строк где встречается паттерн (Samantha)

sed '2,3d' data7 - удалит строки из выходного потока с 2 по 3 по данным файла data7

sed '/number 1/d' data7 - удалит строки из выходного потока по шаблону (где встречается number 1)

insert - i
echo "Test Line 2" | sed 'i\Test Line 1'
Test Line 1
Test Line 2

append - a
echo "Test Line 2" | sed 'a\Test Line 1'
Test Line 2
Test Line 1

change - c
sed '/number 3/c\
> This is a changed line of text.' data7

строка содержащяя паттерн number 3 заменяется на указанную

замена посимвольно
echo "This 1 is a test of 1 try." | sed 'y/123/456/'
This 4 is a test of 4 try.
все 1 заменяются на 4, все 2 на 5 и т.д.

print - p
sed -n '/number 3/p' data7 - вывод только строк сопоставленных с шаблоном (n - убирает все остальные строки)
sed -n '2,3p' data7 - аналогично по диапазону строк

Команда = (знак равенства) выводит номер текущей строки в потоке данных

list- l позволяет вывести управляющие и непечатаемые символы
sed -n 'l' data10

sed '1,2w test' data7 - запись в файл 1 и 2 строк

sed '3r data12' data7 - вставит строки из файла data12 после 3й строки файла data7

sed '/LIST/{
> r data11
> d
> }' letter
вставит после строки содержащей LIST строки из файла data11, после чего удалит саму строку содержащую LIST

sed '/header/{n ; d}' data1 - найдет строку header, перейдет на следующую строку и удалит ее




--gawk--------------------------------------------------------------------------------------------------------------------

gawk '{print $1}' data3 - выведет первое поле (разделитель пробелы) из файла data3
можно указать другой разделитель
gawk -F: '{print $1}' /etc/passwd

echo "My name is Rich" | gawk '{$4="Christine"; print $0}'  - My name is Christine

gawk 'BEGIN { print "The data4 File Contents:" } { print $0 } END { print "End of File" }' data4
выполняется 3 программы, перед обработкой файла (BEGIN), потом вывод всех строк и после обработки файла (END)

echo "This is a test" | gawk '/test/{print $0}'	

FS - разделитель полей во входном файле
OFS - разделитель полей на выводе
FIELDWIDTHS - можно использовать когда нет разделителей, но есть фиксированная ширина столбцов
gawk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' data1b
RS Символ разделителя записей ввода

awk '{FS="|"; print $3}' testout - задать разделитель | и вывести 3 столбец из файла testout

awk '{print "update table1 set f1=\""$1"\" from table1 where ClientId=\""$1"\""}' list - генерит типичный скл запрос по списку клиентов из файла list

FNR Текущий номер записи в файле данных
NF Общее количество полей данных в файле данных
NR Количество обработанных входных записей
awk '{print FNR,$0}' new - выведет строки из файла с номерами записей

переменные среды
$ gawk '
> BEGIN{
> print ENVIRON["HOME"]
> print ENVIRON["PATH"]
> }'
/home/rich
/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin

gawk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd - выведет последнее поле

awk '/Advice/{FIELDWIDTHS="37 1000"; print $2}' rims_new.iqmsg - находит в логе сервера все строки со словом Advice 
и выкусывает кусок сообщения начиная с 38 символа

echo "Create" | awk 'IGNORECASE = 1;/^create/;' - игнорим регистр символов

регулярное выражение должно быть приведено перед левой фигурной скобкой управляемого им программного сценария:
gawk 'BEGIN{FS=","} /11/{print $1}' data1

gawk 'BEGIN{FS=","} $2 ~ /^data2/{print $0}' data1 - В операторе сопоставления второе поле данных сравнивается с регулярным выражением
/^data2/, которое указывает, что строка начинается с текста data2
gawk -F: '$1 ~ /rich/{print $1,$NF}' /etc/passwd

можно также использовать обратное сравнение $1 !~ /expression/

gawk -F: '$4 == 0{print $1}' /etc/passwd - выберет записи где 4е поле равно нулю (это руты)

if (condition) statement1; else statement2
gawk '{
> if ($1 > 20)
> {
>
x = $1 * 2
>
print x
> }
> }' data4

цикл
$ cat data5
130 120 135
160 113 140
145 170 215
$ gawk '{
> total = 0
> i = 1
> while (i < 4)
> {
>
total += $i
>
i++
> }
> avg = total / 3
> print "Average:",avg
> }' data5
Average: 128.333
Average: 137.667
Average: 176.667

awk '/Advice/ && NR < 201  {print FNR,substr($0,match($0, "Advice")+8)}' rims_new.iqmsg
найдет записи с Advice, только те где номер записи менее 201, напечатает номер записи и найдет откуда начинается
слово Advice и выведет подстроку от найденного + 8 символов


--regexp-------------------------------------------------------------------------------------------------------------------
список спецсимволов:
.*[]^${}\+?|()

BRE Basic Regular Expressions----------------

начало строки ^
конец строки $

sed -n '/^this is a test$/p' data4 - ищет строку именно в таком виде
sed '/^$/d' data5 - удалит пустые строки
sed -n '/.at/p' data6 - точка . означает любой символ

классы символов - перечисление возможных значений в []
sed -n '/[ch]at/p' data6 - отберет cat или hat
echo "Yes" | sed -n '/[Yy][Ee][Ss]/p'
sed -n '/^[0-9][0-9][0-9][0-9][0-9]$/p' data8 - выберет только строки из 5 цифр
sed -n '/[a-ch-m]at/p' data6 - 2 диапазона a-c и h-m

Специальные классы символов BRE
[[:alpha:]] Обеспечивает сопоставление с любым буквенным символом, прописным или строчным
[[:alnum:]] Сопоставляется с любым алфавитно-цифровым символом: 0–9, A–Z или a–z
[[:blank:]] Сопоставляется с пробелом или знаком табуляции
[[:digit:]] Сопоставляется с цифрой от 0 до 9
[[:lower:]] Сопоставляется с любым строчным алфавитным символом от a до z
[[:print:]] Сопоставляется с любым печатаемым символом
[[:punct:]] Сопоставляется со знаком пунктуации
[[:space:]] Сопоставляется с любым пробельным символом: пробела, табуляции, перевода на новую строку
(NL), прогона формы (FF), вертикальной табуляции (VT), возврата каретки (CR)
[[:upper:]] Сопоставляется с любым прописным алфавитным символом от A до Z

* - указанная после символа означает что этот символ может быть указан 0 или более раз
echo "I'm getting a color TV" | sed -n '/colou*r/p'

.* - означает любое к-во любых символов

ERE Extended Regular Expressions------------

? - указывает, что предыдущий символ может повторяться нуль или один раз, но не больше
+ - указывает, что предшествующий ему символ может появляться один или несколько раз, но должен
	присутствовать в тексте не меньше, чем в одном экземпляре.

{} - интервал, или к-во сколько раз должно присутствовать выражение	
echo "bet" | gawk --re-interval '/be{1}t/{print $0}' - be должно присутствовать четко 1 раз и не больше

| - или. Можно группировать разные регулярные выражения
echo "The cat is asleep" | gawk '/cat|dog/{print $0}'

() - группировка выражения. В таком случае содержимое скобок рассматривается как 1 символ и к нему применяются спец.символы
echo "Sat" | gawk '/Sat(urday)?/{print $0}'
echo "cat" | gawk '/(c|b)a(b|t)/{print $0}'

/(?=.*a)(?=.*b)(?=.*c)/ - проверит наличие a b и c в строке, в любом месте (И - AND)
















