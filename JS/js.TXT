в жс всё обьекты кроме:
  - чисел, строк, логического типа, null и undefined
  при этом первые 3 имеют обёртки, которые преобразуют их в обьекты.
  
при создании любой переменной она представляет собой свойство 
глобального обьекти или обьекта активации.

глобальный обьект доступен через this вне функций. 
для удобства глобальный обьект в браузерах имеет доп.свойство window, которое ссылается на сам гл.обьект this
если функция содержит this и вызывается не как конструктор (new), то this ссылается на глобальный обьект

любая переменная обладает свойствами определяющими доступность для удаления, изменения и использования в for-in

существуют встроенные обьекты (типа Data, Array или свои var o = {};) 
и обьекты окружения (например window и все обьекты DOM)  

каждая функция имеет свойство prototype

use strict введено в ES5 для того, чтобы при ее использовании не работали устаревшие части языка 
(действует на область видимости где использована)

любая необьявленная через var переменная становится глобальной (свойством гл.обьекта)
это называется - подразумеваемая переменная.
отличие от глобальной обьявленной через var в том, что подразумеваемую можно удалить с помощью delete (удаление свойств).
для предотвращения появления подразумеваемых переменных использовать use strict.

function (){ var a = b = 0;}
b будет глобальной
выражения присваивания выполняются справа налево


шаблон единственной инструкции var
переменный и функции обьявляются в одном месте в начале

следует избегать разбросанных обьявлений переменных т.к. возникают ошибки вследствие правила "подьема переменных"

for(var i = 0; i < myarr.length; i++) - плохо
длина будет вычисляться каждую итерацию цикла

var i = 0,
    max;
for(i = 0, max = myarr.length; i < max; i++) - хорошо
длина вычислится один раз + выносим обьявление переменных в одно место.

 цикл по убыванию немного быстрее за счет того, что сравнение с нулем происходит быстрее чем с длиной массива.
  while(i--){}
 
в циклах for-in желательно использовать проверку hasOwnProperty,
чтобы в обработку не попали унаследованные свойства от прототипа
хотя лишняя проверка может замедлить работу, поэтому это зависит от задачи.

в if() любые значения истины (в том числе пустой обьект) кроме:
undefined
null
NaN
false
0
""

рекомендуется всегда использовать === и !==, чтобы избежать ошибок с неявным преобразованием типа.

всегда указывайте систему счисления в функции parseInt

всегда ставить { в конце строки (а не переносить на следующую) т.к. может быть автоматом проставлена ;
ставить пробел между (...) и {
всегда ставить ; там где она подразумевается

члены классов в конструкторах (обьектов) общие для всех экземпляров нужно добавлять в prototype для экономии
например методы 

для проверки является ли переменная массивом использовать Array.isArray()
 
осторожно с функциями-выражениями, они как и переменные поднимаются вверх области видимости
f(); //undefined
var f = function(){ return 1; }

если метод обьекта использует this для обращения к свойствам этого обьекта, 
то когда он передается как колбэк функция this указывает уже на совсем другой обьект.
поэтому нужно вызывать колбэк в контексте нужного обьекта с помощью call


 шаблон мемоизации (кэширование результатов функции), запись результатов в свойство функции, 
 название которого определяется набором параметров (например через JSON.stringify)
 
 каррирование: разбиение функции на два этапа, первый вызов получает часть параметров и возвращает функцию,
 потом при вызове этой функции можно использовать меньшее к-во параметров. 
 (разовая настройка начальных параметров, которые нет смысл передавать каждый раз)
 
function schonfinkelize(fn){
         var slice = Array.prototype.slice,
            stored_args = slice.apply(arguments, [1]);
        console.log(stored_args);
        return function(){
            console.log(arguments);
            var new_args = slice.call(arguments),
                args = stored_args.concat(new_args);
            return fn.apply(null, args);
        };
    }

    function add(x, y){
        return x + y;
    }

    var newAdd = schonfinkelize(add, 5);

    console.log(newAdd(4));
    
    
    
статические члены:
var Class = function(param){
    this.prop = param;
};

    Class.staticMethod = function(){
        return this.prop;
    };

    Class.prototype.dynamicMethod = function(){
        return this.prop;
    };

    Class.prototype.staticMethod = Class.staticMethod; - таким образом делаем возможность вызывать статический метод в контексте экземпляра обьекта

    var var1 = new Class(1);
    var var2 = new Class(2);
    var var3 = new Class(3);
    
        this = функции конструктору в случае вызова метода класс ( Class.staticMethod())
        this = обьекту в случае вызова в контексте обьекта var1.staticMethod()
    
    
статические поля, пример:
    var Class = (function () {

        var counter = 0;

        function newClass() {
            counter++;
        }

        newClass.prototype.getLastId = function () {
            return counter;
        };

        return newClass;

    })();

шаблон цепочек: если методы не возвращают какогото осмысленного значения, можно возвращать this
плюсы:
читабельность, меньше кода, разбиение кода на более мелкие части.
минусы:
отладка - указывается строка с ошибкой, но в каком вызове ошибка не ясно.
примеры использования шаблона: jquery, DOM


Наследование:
способы:
1. через присвоение в свойство prototype дочернего обьекта - родительского обьекта
function inherit(c, p){ c.prototype = new p(); }
(в данном случае имеем ссылку в цепочке прототипов на родительский обьект, можем его изменить)

2. через вызов в дочернем конструкторе конструктора родителя в контексте дочернего 
function Child(){ Parent.call(this); }  
(в этом случае имеем в дочернем обьекте копии свойств родительского)

обьединяющий способ:

function inherit = 
(function(){
var F = function(){};
return function(C, P){
F.prototype = P.prototype;
C.prototype = new F();
C.uber = P.prototype;
C.prototype.constructor = C;
}
}());
    
В ECMAScript5 появилась возможность создавать обьекты на основании родительских обьектов
var child = Object.create(parent);

Заимствование методов:
пример:
var myobj = {1: 'a', 2: 'b', 3: 'c', 4: 'd', length: 4}; 
Array.prototype.slice.call(myobj, 1, 3) или [].slice.apply(myobj, [1, 3]); => ["b"]
 

 

    
    
    