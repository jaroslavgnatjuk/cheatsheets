в js есть 6 типов:
	5 примитивных:
		number, string, boolean, null, undefined
	1 обьектный: object.

в js всё обьекты кроме:
  - чисел, строк, логического типа, null и undefined
  при этом первые 3 имеют обёртки, которые преобразуют их в обьекты.
  
  функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. 
  Но typeof выделяет функции отдельно, возвращая для них "function". На практике это весьма удобно, так как позволяет легко определить функцию.
  
Преобразования:
Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
null не подчиняется законам математики – он «больше либо равен нулю»: null>=0, но не больше и не равен

>= > < <= - приводят к числу оба операнда
поэтому 
alert( null == 0 ); // false 
alert(null >= 0); // true  

Значение undefined вообще нельзя сравнивать
undefined при преобразовании к числу даёт NaN

Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов (кроме сравнений ===, !==).

Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс "+":
При преобразовании строки к числу:
Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

при сравнении булеан и числа, булеан преобразуется к числу

В JavaScript есть три преобразования:

Строковое: String(value) – в строковом контексте или при сложении со строкой. Работает очевидным образом.
Численное: Number(value) – в численном контексте, включая унарный плюс +value. Происходит при сравнении разных типов, кроме строгого равенства.
Логическое: Boolean(value) – в логическом контексте, можно также сделать двойным НЕ: !!value.
  
Числа
Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».
alert( 1 / 0 ); // Infinity
alert( 12345 / 0 ); // Infinity
alert( 0 / 0 ); // NaN
Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу. В худшем случае, результат будет NaN.
alert( parseInt('12px') ); // 12
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
alert( parseInt('FF', 16) ); // 255

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

var n = 255; alert( n.toString(16) ); // ff
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():

 var number = 123456789;

alert( number.toLocaleString() ); // 123 456 789

------------------------------------------------------------------------------------
Function Declaration – функция, объявленная в основном потоке кода.
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.

Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.  



  
  при создании любой переменной она представляет собой свойство 
глобального обьекти или обьекта активации.

глобальный обьект доступен через this вне функций. 
для удобства глобальный обьект в браузерах имеет доп.свойство window, которое ссылается на сам гл.обьект this
если функция содержит this и вызывается не как конструктор (new), то this ссылается на глобальный обьект

любая переменная обладает свойствами определяющими доступность для удаления, изменения и использования в for-in

существуют встроенные обьекты (типа Data, Array или свои var o = {};) 
и обьекты окружения (например window и все обьекты DOM)  

каждая функция имеет свойство prototype

use strict введено в ES5 для того, чтобы при ее использовании не работали устаревшие части языка 
(действует на область видимости где использована)

любая необьявленная через var переменная становится глобальной (свойством гл.обьекта)
это называется - подразумеваемая переменная.
отличие от глобальной обьявленной через var в том, что подразумеваемую можно удалить с помощью delete (удаление свойств).
для предотвращения появления подразумеваемых переменных использовать use strict.

function (){ var a = b = 0;}
b будет глобальной
выражения присваивания выполняются справа налево


шаблон единственной инструкции var
переменный и функции обьявляются в одном месте в начале

следует избегать разбросанных обьявлений переменных т.к. возникают ошибки вследствие правила "подьема переменных"

for(var i = 0; i < myarr.length; i++) - плохо
длина будет вычисляться каждую итерацию цикла

var i = 0,
    max;
for(i = 0, max = myarr.length; i < max; i++) - хорошо
длина вычислится один раз + выносим обьявление переменных в одно место.

 цикл по убыванию немного быстрее за счет того, что сравнение с нулем происходит быстрее чем с длиной массива.
  while(i--){}
 
в циклах for-in желательно использовать проверку hasOwnProperty,
чтобы в обработку не попали унаследованные свойства от прототипа
хотя лишняя проверка может замедлить работу, поэтому это зависит от задачи.

в if() любые значения истины (в том числе пустой обьект) кроме:
undefined
null
NaN
false
0
""

рекомендуется всегда использовать === и !==, чтобы избежать ошибок с неявным преобразованием типа.

всегда указывайте систему счисления в функции parseInt

всегда ставить { в конце строки (а не переносить на следующую) т.к. может быть автоматом проставлена ;
ставить пробел между (...) и {
всегда ставить ; там где она подразумевается

члены классов в конструкторах (обьектов) общие для всех экземпляров нужно добавлять в prototype для экономии
например методы 

для проверки является ли переменная массивом использовать Array.isArray()
 
осторожно с функциями-выражениями, они как и переменные поднимаются вверх области видимости
f(); //undefined
var f = function(){ return 1; }

если метод обьекта использует this для обращения к свойствам этого обьекта, 
то когда он передается как колбэк функция this указывает уже на совсем другой обьект.
поэтому нужно вызывать колбэк в контексте нужного обьекта с помощью call

«Понимать замыкания» в JavaScript означает понимать следующие вещи:

Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».

При строковом преобразовании объекта используется его метод toString. Он должен возвращать примитивное значение, причём не обязательно именно строку.
Для численного преобразования используется метод valueOf, который также может возвратить любое примитивное значение. У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString.


функция, запущенная через new, делает следующее:

Создаётся новый пустой объект.
Ключевое слово this получает ссылку на этот объект.
Функция выполняется. Как правило, она модифицирует this, добавляет методы, свойства.
Возвращается this.

Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.

Но если явный вызов return всё же есть, то применяется простое правило:

При вызове return с объектом, будет возвращён он, а не this.
При вызове return с примитивным значением, оно будет отброшено.
Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this.

Дескрипторы, геттеры и сеттеры свойств
Object.defineProperty(obj, prop, descriptor)
Аргументы:

obj
Объект, в котором объявляется свойство.
prop
Имя свойства, которое нужно объявить или модифицировать.
descriptor
Дескриптор – объект, который описывает поведение свойства.
В нём могут быть следующие поля:

value – значение свойства, по умолчанию undefined
writable – значение свойства можно менять, если true. По умолчанию false.
configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
get – функция, которая возвращает значение свойства. По умолчанию undefined.
set – функция, которая записывает значение свойства. По умолчанию undefined.

var user = {
  firstName: "Вася",
  surname: "Петров"
}

Object.defineProperty(user, "fullName", {

  get: function() {
    return this.firstName + ' ' + this.surname;
  },

  set: function(value) {
      var split = value.split(' ');
      this.firstName = split[0];
      this.surname = split[1];
    }
});
var user = {
  firstName: "Вася",
  surname: "Петров",

  get fullName() {
    return this.firstName + ' ' + this.surname;
  },

  set fullName(value) {
    var split = value.split(' ');
    this.firstName = split[0];
    this.surname = split[1];
  }
};

Object.keys возвращает только enumerable-свойства.
Object.getOwnPropertyNames – возвращает все
Object.getOwnPropertyDescriptor(obj, prop)
Возвращает дескриптор для свойства obj[prop].
var descriptor = Object.getOwnPropertyDescriptor(obj, 'test');

// заменим value на геттер, для этого...
delete descriptor.value; // ..нужно убрать value/writable
delete descriptor.writable;
descriptor.get = function() { // и поставить get
  alert( "Preved :)" );
};
Object.preventExtensions(obj)
Запрещает добавление свойств в объект.
Object.seal(obj)
Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.
Object.freeze(obj)
Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.
Object.isExtensible(obj)
Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.
Object.isSealed(obj)
Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.
Object.isFrozen(obj)
Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.


Статические методы

С примерами статических методов мы уже знакомы: это встроенные методы String.fromCharCode, Date.parse.
Создадим для Article статический метод Article.showCount():

function Article() {
  Article.count++;

  //...
}
Article.count = 0;

Article.showCount = function() {
  alert( this.count ); // (1)
}

// использование
new Article();
new Article();
Article.showCount(); // (2)


Фабричные методы
примеры:
new Date() – создаёт объект с текущей датой,
new Date(milliseconds) – создаёт дату по количеству миллисекунд milliseconds,
new Date(year, month, day ...) – создаёт дату по компонентам год, месяц, день…
new Date(datestring) – читает дату из строки datestring

function User() {
  this.sayHi = function() {
    alert(this.name)
  };
}

User.createAnonymous = function() {
  var user = new User;
  user.name = 'Аноним';
  return user;
}

User.createFromData = function(userData) {
  var user = new User;
  user.name = userData.name;
  user.age = userData.age;
  return user;
}

// Использование

var guest = User.createAnonymous();
guest.sayHi(); // Аноним

var knownUser = User.createFromData({
  name: 'Вася',
  age: 25
});
knownUser.sayHi(); // Вася

Одалживание метода:
function printArgs() {
  arguments.join = [].join; // одолжили метод (1)

  var argStr = arguments.join(':'); // (2)

  alert( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);

и более безопасный вариант (не перезапишет метод join, если он уже есть):
function printArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную

  // вызовем join с this=arguments,
  // этот вызов эквивалентен arguments.join(':') из примера выше
  var argStr = join.call(arguments, ':');

  alert( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);

var args = [].slice.call(arguments); - скопирует аргументы в массив


Потеря контекста:
var user = {
  firstName: "Вася",
  sayHi: function() {
    alert( this.firstName );
  }
};

setTimeout(user.sayHi, 1000); // undefined (не Вася!)

в таймаут передалась сама функция, без контекста, т.к. она только передается, а не вызывается

чтобы не терять контекст можно:
1. сделать функцию обертку, в которой будет уже сам вызов
setTimeout(function() {
  user.sayHi(); // Вася
}, 1000);

2. сделать фукнцию байнд которая будет вызывать аплай
function bind(func, context) {
  return function() {
    return func.apply(context, arguments);
  };
}

var user = {
  firstName: "Вася",
  sayHi: function() {
    alert( this.firstName );
  }
};

setTimeout(bind(user.sayHi, user), 1000);

setTimeout(user.sayHi.bind(user), 1000); // аналог через встроенный метод







 шаблон мемоизации (кэширование результатов функции), запись результатов в свойство функции, 
 название которого определяется набором параметров (например через JSON.stringify)
 
 каррирование: разбиение функции на два этапа, первый вызов получает часть параметров и возвращает функцию,
 потом при вызове этой функции можно использовать меньшее к-во параметров. 
 (разовая настройка начальных параметров, которые нет смысл передавать каждый раз)
 
function schonfinkelize(fn){
         var slice = Array.prototype.slice,
            stored_args = slice.apply(arguments, [1]);
        console.log(stored_args);
        return function(){
            console.log(arguments);
            var new_args = slice.call(arguments),
                args = stored_args.concat(new_args);
            return fn.apply(null, args);
        };
    }

    function add(x, y){
        return x + y;
    }

    var newAdd = schonfinkelize(add, 5);

    console.log(newAdd(4));
    

и пример со встроенной фукнцией bind:
    function mul(a, b) {
  return a * b;
};
При помощи bind создадим функцию double, удваивающую значения. Это будет вариант функции mul с фиксированным первым аргументом:

// double умножает только на два
var double = mul.bind(null, 2); // контекст фиксируем null, он не используется

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10





    
    
статические члены:
var Class = function(param){
    this.prop = param;
};

    Class.staticMethod = function(){
        return this.prop;
    };

    Class.prototype.dynamicMethod = function(){
        return this.prop;
    };

    Class.prototype.staticMethod = Class.staticMethod; - таким образом делаем возможность вызывать статический метод в контексте экземпляра обьекта

    var var1 = new Class(1);
    var var2 = new Class(2);
    var var3 = new Class(3);
    
        this = функции конструктору в случае вызова метода класс ( Class.staticMethod())
        this = обьекту в случае вызова в контексте обьекта var1.staticMethod()
    
    
статические поля, пример:
    var Class = (function () {

        var counter = 0;

        function newClass() {
            counter++;
        }

        newClass.prototype.getLastId = function () {
            return counter;
        };

        return newClass;

    })();

шаблон цепочек: если методы не возвращают какогото осмысленного значения, можно возвращать this
плюсы:
читабельность, меньше кода, разбиение кода на более мелкие части.
минусы:
отладка - указывается строка с ошибкой, но в каком вызове ошибка не ясно.
примеры использования шаблона: jquery, DOM


Наследование:
способы:
1. через присвоение в свойство prototype дочернего обьекта - родительского обьекта
function inherit(c, p){ c.prototype = new p(); }
(в данном случае имеем ссылку в цепочке прототипов на родительский обьект, можем его изменить)

2. через вызов в дочернем конструкторе конструктора родителя в контексте дочернего 
function Child(){ Parent.call(this); }  
(в этом случае имеем в дочернем обьекте копии свойств родительского)

обьединяющий способ:

function inherit = 
(function(){
var F = function(){};
return function(C, P){
F.prototype = P.prototype;
C.prototype = new F();
C.uber = P.prototype;
C.prototype.constructor = C;
}
}());
    
В ECMAScript5 появилась возможность создавать обьекты на основании родительских обьектов
var child = Object.create(parent);

Заимствование методов:
пример:
var myobj = {1: 'a', 2: 'b', 3: 'c', 4: 'd', length: 4}; 
Array.prototype.slice.call(myobj, 1, 3) или [].slice.apply(myobj, [1, 3]); => ["b"]
 

 

Прототипы    
Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__.
Обычный цикл for..in не делает различия между свойствами объекта и его прототипа
hasOwnProperty нужно испльзовать для определения именно своих свойств, а не прототипа
for (var key in rabbit) {
  if (!rabbit.hasOwnProperty(key)) continue; // пропустить "не свои" свойства
  alert( key + " = " + rabbit[key] ); // выводит только "jumps"
}

в обычный обьект всегда добавляются свойства прототипа типа toString, 
если нужно чтобы был абсолютно пустой, то делаем так:
var data = Object.create(null);
data.text = "Привет";

alert(data.text); // Привет
alert(data.toString); // undefined
Объект, создаваемый при помощи Object.create(null) не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо. 

В современных браузерах есть методы для работы с прототипом:
Object.getPrototypeOf(obj) (кроме IE8-)
Object.setPrototypeOf(obj, proto) (кроме IE10-)
Object.create(proto, descriptors) (кроме IE8-)

Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.
При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.
Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit запиши ему __proto__ = animal".

Свойство prototype имеет смысл только у конструктора

при создании обьекта с помощью конструктора (new Class()) у него в __proto__ попадает constructor: Class
при создании с помщью литерала - будет Object с кучей свойств типа toString и тд
Откуда новый объект obj получает такой __proto__?

Запись obj = {} является краткой формой obj = new Object, где Object – встроенная функция-конструктор для объектов.
При выполнении new Object, создаваемому объекту ставится __proto__ по prototype конструктора, который в данном случае равен встроенному Object.prototype.
В дальнейшем при обращении к obj.toString() – функция будет взята из Object.prototype.

Объект Object.prototype – вершина иерархии, единственный, у которого __proto__ равно null.

Поэтому говорят, что "все объекты наследуют от Object", а если более точно, то от Object.prototype.




