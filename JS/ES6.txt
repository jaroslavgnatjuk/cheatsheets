----------------------------------------------------------------------------------------------------------------------------------------------------
let
1. Область видимости переменной let – блок {...}.
2. Переменная let видна только после объявления.
	Заметим также, что переменные let нельзя повторно объявлять
3. При использовании в цикле, для каждой итерации создаётся своя переменная.	
	Каждому повторению цикла соответствует своя независимая переменная let. Если внутри цикла есть вложенные объявления функций, 
		то в замыкании каждой будет та переменная, которая была при соответствующей итерации.
----------------------------------------------------------------------------------------------------------------------------------------------------		
const
Объявление const задаёт константу, то есть переменную, которую нельзя менять		
В остальном объявление const полностью аналогично let.
Заметим, что если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё.
----------------------------------------------------------------------------------------------------------------------------------------------------
Деструктуризация
Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части

let {prop : varName = default, ...} = object
Здесь двоеточие : задаёт отображение свойства prop в переменную varName, а равенство =default задаёт выражение, которое будет использовано, если значение отсутствует (не указано или undefined).

Для массивов имеет значение порядок, поэтому нельзя использовать :, но значение по умолчанию – можно:

let [var1 = default, var2, ...rest] = array
Объявление переменной в начале конструкции не обязательно. Можно использовать и существующие переменные. Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.

Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора "..."
let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
Значением rest будет массив из оставшихся элементов массива. Вместо rest можно использовать и другое имя переменной, оператор здесь – троеточие. Оно должно стоять только последним элементом в списке слева.

Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}

let { title="Меню", size: {width, height}, items: [item1, item2] } = options;
---------------------------------------------------------------------------------------------------------------------------------------------------
Функции
Параметры по умолчанию
function showMenu(title = "Без заголовка", width = 100, height = 200) {
  alert(title + ' ' + width + ' ' + height);
}
При передаче любого значения, кроме undefined, включая пустую строку, ноль или null, параметр считается переданным, и значение по умолчанию не используется.
Параметры по умолчанию могут быть не только значениями, но и выражениями.

 function sayHi(who = getCurrentUser().toUpperCase()) {}
 
Оператор spread вместо arguments
Чтобы получить массив аргументов, можно использовать оператор …, например:
function showName(firstName, lastName, ...rest) {
  alert(firstName + ' ' + lastName + ' - ' + rest);
}
В rest попадёт массив всех аргументов, начиная со второго. Оператор … должен быть в конце.

Формально говоря, эти два вызова делают одно и то же:
Math.max(...numbers);
Math.max.apply(Math, numbers);
Похоже, что первый – короче и красивее.

Деструктуризация в параметрах
function showMenu({title, width, height}) - деструктуризация обьекта переданного в параметрах вызова функции
function showMenu({title="Заголовок", width:w=100, height:h=200}) - аналогично, с параметрами по умолчанию в деструктуризации
function showMenu({title="Заголовок", width:w=100, height:h=200} = {}) - аналогично, если вдруг вообще ни какой обьект не будет передан
---------------------------------------------------------------------------------------------------------------------------------------------------
добавлено свойство name для функций:
// свойство g.name = "g"
let g = function() {};

let user = {
  // свойство user.sayHi.name == "sayHi"
  sayHi: function() {}
};
---------------------------------------------------------------------------------------------------------------------------------------------------
Функции в блоке
Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.
if (true) {

  sayHi(); // работает

  function sayHi() {
    alert("Привет!");
  }

}
sayHi(); // ошибка, функции не существует
---------------------------------------------------------------------------------------------------------------------------------------------------
Функции через =>
let inc = x => x+1;
тоже самое что и:
let inc = function(x) { return x + 1; };

let sum = (a,b) => a + b;

как только тело функции оборачивается в {…}, то её результат уже не возвращается автоматически. 
Такая функция должна делать явный return, как в примере выше, если конечно хочет что-либо возвратить.

Функции-стрелки не имеют своего this.
Это очень удобно в обработчиках событий и коллбэках
let group = {
  title: "Наш курс",
  students: ["Вася", "Петя", "Даша"],

  showList: function() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    )
  }
}
Функции-стрелки не имеют своего arguments
В качестве arguments используются аргументы внешней «обычной» функции.
---------------------------------------------------------------------------------------------------------------------------------------------------
Строки
` - апостроф
В них разрешён перевод строки:
alert(`моя
  многострочная
  строка`);
  
Можно вставлять выражения при помощи ${…}:
alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5

Как видно, при помощи ${…} можно вставлять как и значение переменной ${apples}, 
так и более сложные выражения, которые могут включать в себя операторы, вызовы функций и т.п. Такую вставку называют «интерполяцией».
---------------------------------------------------------------------------------------------------------------------------------------------------
Функции шаблонизации
Название этой функции ставится перед первой обратной кавычкой:

let str = func`моя строка`;
function f(strings, ...values) {
  alert(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
  alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
  alert(JSON.stringify(values));      // [3,5,8]
}

let apples = 3;
let oranges = 5;

//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
В примере выше видно, что строка разбивается по очереди на части: «кусок строки» – «параметр» – «кусок строки» – «параметр».

Участки строки идут в первый аргумент-массив strings.
У этого массива есть дополнительное свойство strings.raw. В нём находятся строки в точности как в оригинале. 
Это влияет на спец-символы, например в strings символ \n – это перевод строки, а в strings.raw – это именно два символа \n.
Дальнейший список аргументов функции шаблонизации – это значения выражений в ${...}, в данном случае их три.
---------------------------------------------------------------------------------------------------------------------------------------------------
Добавлены ряд полезных методов общего назначения:

str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.
str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.
str.startsWith(s) – возвращает true, если строка str начинается со строки s.
str.repeat(times) – повторяет строку str times раз.
---------------------------------------------------------------------------------------------------------------------------------------------------
Объекты и прототипы
поля обьекта из переменных:
let name = "Вася";
let isAdmin = true;

let user = {
  name,
  isAdmin
};

Вычисляемые свойства
let propName = "firstName";

let user = {
  [propName]: "Вася"
};

let a = "Мой ";
let b = "Зелёный ";
let c = "Крокодил";

let user = {
  [(a + b + c).toLowerCase()]: "Вася"
};

alert( user["мой зелёный крокодил"] ); // Вася

Object.setPrototypeOf(obj, newProto) - появился

А также «узаконено» свойство __proto__, которое даёт прямой доступ к прототипу. 
Его, в качестве «нестандартного», но удобного способа работы с прототипом, реализовали почти все браузеры (кроме IE10-), 
так что было принято решение добавить его в стандарт.
---------------------------------------------------------------------------------------------------------------------------------------------------
Object.assign
Функция Object.assign получает список объектов и копирует в первый target свойства из остальных.
Object.assign(target, src1, src2...)
При этом последующие свойства перезаписывают предыдущие.
Его также можно использовать для 1-уровневого клонирования объекта:
// clone = пустой объект + все свойства user
let clone = Object.assign({}, user);
---------------------------------------------------------------------------------------------------------------------------------------------------
Методы объекта
Более короткий синтаксис объявления.
Наличие в методах специального внутреннего свойства [[HomeObject]] («домашний объект»), ссылающегося на объект, которому метод принадлежит. Мы посмотрим его использование чуть дальше.
Для объявления метода вместо записи "prop: function() {…}" нужно написать просто "prop() { … }".
---------------------------------------------------------------------------------------------------------------------------------------------------
super
Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа.
работает только в методах, в свойствах функциях не будет работать т.к. обычная функция не имеет свойства super
---------------------------------------------------------------------------------------------------------------------------------------------------
Class
class Название [extends Родитель]  {
  constructor
  методы
}

class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

let user = new User("Вася");
user.sayHi(); // Вася

Это объявление примерно аналогично такому:

function User(name) {
  this.name = name;
}

User.prototype.sayHi = function() {
  alert(this.name);
};
В обоих случаях new User будет создавать объекты. Метод sayHi также в обоих случаях находится в прототипе.

Но при объявлении через class есть и ряд отличий:

User нельзя вызывать без new, будет ошибка.
Объявление класса с точки зрения области видимости ведёт себя как let. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).
Методы, объявленные внутри class, также имеют ряд особенностей:

Метод sayHi является именно методом, то есть имеет доступ к super.
Все методы класса работают в строгом режиме use strict, даже если он не указан.
Все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет.
---------------------------------------------------------------------------------------------------------------------------------------------------
Class Expression
let User = class {
  sayHi() { alert('Привет!'); }
};

new User().sayHi();
---------------------------------------------------------------------------------------------------------------------------------------------------
Геттеры, сеттеры и вычисляемые свойства
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  // геттер
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  // сеттер
  set fullName(newValue) {
    [this.firstName, this.lastName] = newValue.split(' ');
  }
  // вычисляемое название метода
  ["test".toUpperCase()]() {
    alert("PASSED!");
  }
};
---------------------------------------------------------------------------------------------------------------------------------------------------
Статические свойства
class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  static createGuest() {
    return new User("Гость", "Сайта");
  }
};
---------------------------------------------------------------------------------------------------------------------------------------------------
Наследование
class Animal {
  constructor(name) {
    this.name = name;
  }

  walk() {
    alert("I walk: " + this.name);
  }
}

class Rabbit extends Animal {
  walk() {
    super.walk();
    alert("...and jump!");
  }
}

new Rabbit("Вася").walk();
// I walk: Вася
// and jump!
alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true
---------------------------------------------------------------------------------------------------------------------------------------------------
Вызов конструктора родителя:
class Rabbit extends Animal {
  constructor() {
    // вызвать конструктор Animal с аргументом "Кроль"
    super("Кроль"); // то же, что и Animal.call(this, "Кроль")
  }
}
Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
В конструкторе потомка мы обязаны вызвать super() до обращения к this. До вызова super не существует this, так как по спецификации в этом случае именно super инициализует this.
---------------------------------------------------------------------------------------------------------------------------------------------------
Тип данных Symbol
Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов
let sym = Symbol();
alert( typeof sym ); // symbol
Каждый символ – уникален. У функции Symbol есть необязательный аргумент «имя символа». Его можно использовать для описания символа, в целях отладки:
alert( Symbol("name") == Symbol("name") ); // false
---------------------------------------------------------------------------------------------------------------------------------------------------
Глобальные символы
Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.
Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).
// создание символа в реестре
let name = Symbol.for("name");

// символ уже есть, чтение из реестра
alert( Symbol.for("name") == name ); // true
// получение имени символа
alert( Symbol.keyFor(name) ); // name -  работает только для глобальных символов

Особенность символов в том, что если в объект записать свойство-символ, то оно не участвует в итерации
Кроме того, свойство-символ недоступно, если обратиться к его названию: user.isAdmin не существует
---------------------------------------------------------------------------------------------------------------------------------------------------
Итераторы
let arr = [1, 2, 3]; // массив — пример итерируемого объекта
for (let value of arr) {
  alert(value); // 1, затем 2, затем 3
}
for (let char of "Привет") {
  alert(char); // Выведет по одной букве: П, р, и, в, е, т
}
Для возможности использовать объект в for..of нужно создать в нём свойство с названием Symbol.iterator (системный символ).

// сделаем объект range итерируемым
range[Symbol.iterator] = function() {

  let current = this.from;
  let last = this.to;

  // метод должен вернуть объект с методом next()
  return {
    next() {
      if (current <= last) {
        return {
          done: false,
          value: current++
        };
      } else {
        return {
          done: true
        };
      }
    }

  }
};
---------------------------------------------------------------------------------------------------------------------------------------------------
Встроенные итераторы
let str = "Hello";

// Делает то же, что и
// for (var letter of str) alert(letter);

let iterator = str[Symbol.iterator]();

while(true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // Выведет все буквы по очереди
}
---------------------------------------------------------------------------------------------------------------------------------------------------
Map
Map – коллекция для хранения записей вида ключ:значение.
В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение
например 
map.set('1', 'str1');   // ключ-строка
map.set(1, 'num1');     // число
Метод set можно чейнить:
map
  .set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');

При создании Map можно сразу инициализировать списком значений.
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
В качестве ключей map можно использовать и объекты
Методы:
map.delete(key) удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.
map.clear() – удаляет все записи, очищает map.
map.has(key) – возвращает true, если ключ есть, иначе false.

Для итерации по map используется один из трёх методов:

map.keys() – возвращает итерируемый объект для ключей,
map.values() – возвращает итерируемый объект для значений,
map.entries() – возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of.

for(let fruit of recipeMap.keys()) {
  alert(fruit); // огурцов, помидоров, сметаны
}

// цикл по значениям [ключ,значение]
for(let amount of recipeMap.values()) {
  alert(amount); // 500 гр, 350 гр, 50 гр
}

// цикл по записям
for(let entry of recipeMap) { // то же что и recipeMap.entries()
  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения
}
Перебор осуществляется в порядке вставки. Объекты Map гарантируют это, в отличие от обычных объектов Object.
Кроме того, у Map есть стандартный метод forEach, аналогичный массиву
---------------------------------------------------------------------------------------------------------------------------------------------------
Set
Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.
set.add(item) – добавляет в коллекцию item, возвращает set (чейнится).
set.delete(item) – удаляет item из коллекции, возвращает true, если он там был, иначе false.
set.has(item) – возвращает true, если item есть в коллекции, иначе false.
set.clear() – очищает set.
Перебор Set осуществляется через forEach или for..of аналогично Map
---------------------------------------------------------------------------------------------------------------------------------------------------
WeakMap и WeakSet – «урезанные» по функционалу варианты Map/Set, 
которые позволяют только «точечно» обращаться элементам (по конкретному ключу или значению). 
Они не препятствуют сборке мусора, то есть если ссылка на объект осталась только в WeakSet/WeakMap – он будет удалён.
---------------------------------------------------------------------------------------------------------------------------------------------------
Promise
Promise – предоставляют удобный способ организации асинхронного кода.
Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), 
затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

// Создаётся объект promise
let promise = new Promise((resolve, reject) => {

  setTimeout(() => {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);

});

// promise.then навешивает обработчики на успешный результат или ошибку
promise
  .then(
    result => {
      // первая функция-обработчик - запустится при вызове resolve
      alert("Fulfilled: " + result); // result - аргумент resolve
    },
    error => {
      // вторая функция - запустится при вызове reject
      alert("Rejected: " + error); // error - аргумент reject
    }
  );
---------------------------------------------------------------------------------------------------------------------------------------------------
Промисификация - делаем обертку возвращающую промис для асинхронного кода:
function httpGet(url) {

  return new Promise(function(resolve, reject) {

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);

    xhr.onload = function() {
      if (this.status == 200) {
        resolve(this.response);
      } else {
        var error = new Error(this.statusText);
        error.code = this.status;
        reject(error);
      }
    };

    xhr.onerror = function() {
      reject(new Error("Network Error"));
    };

    xhr.send();
  });
}

httpGet("/article/promise/user.json")
  .then(
    response => alert(`Fulfilled: ${response}`),
    error => alert(`Rejected: ${error}`)
  );
---------------------------------------------------------------------------------------------------------------------------------------------------
Promise.all(iterable)
Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, 
который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
---------------------------------------------------------------------------------------------------------------------------------------------------
Promise.race(iterable)
результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются
---------------------------------------------------------------------------------------------------------------------------------------------------
Promise.resolve(value)
Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.
---------------------------------------------------------------------------------------------------------------------------------------------------
пример построения последовательной цепочки промисов
let chain = Promise.resolve();
let urls = ['url 1', 'url 2', 'url 3'];

function async(url) {
  return new Promise((suc, rej) => {
    setTimeout(() => {
      suc(url);
    }, 1000);
  });
}

urls.forEach(function(url) {
  chain = chain
    .then(() => async(url))
    .then((result) => {
      console.log(result);
    });
});
---------------------------------------------------------------------------------------------------------------------------------------------------
Генераторы
Функции, которые могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
let generator = generateSequence();
let one = generator.next();
alert(JSON.stringify(one)); // {value: 1, done: false}
let two = generator.next();
alert(JSON.stringify(two)); // {value: 2, done: false}
let three = generator.next();
alert(JSON.stringify(three)); // {value: 3, done: true}

for(let value of generator) {
  alert(value); // 1, затем 2, затем 3
}

Вызов let result = yield value делает следующее:

Возвращает value во внешний код, приостанавливая выполнение генератора.
Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
Генератор продолжит выполнение, аргумент next будет возвращён как результат yield (и записан в result).

function* gen() {
  // Передать вопрос во внешний код и подождать ответа
  let result = yield "Сколько будет 2 + 2?";

  alert(result);
}

let generator = gen();

let question = generator.next().value;
// "Сколько будет 2 + 2?"

setTimeout(() => generator.next(4), 2000);

Первый вызов generator.next() – всегда без аргумента, он начинает выполнение и возвращает результат первого yield («Сколько будет 2+2?»). 
На этой точке генератор приостанавливает выполнение.
Результат yield переходит во внешний код (в question). Внешний код может выполнять любые асинхронные задачи, генератор стоит «на паузе».
Когда асинхронные задачи готовы, внешний код вызывает generator.next(4) с аргументом. 
Выполнение генератора возобновляется, а 4 выходит из присваивания как результат let result = yield ....
---------------------------------------------------------------------------------------------------------------------------------------------------
Плоский асинхронный код
Одна из основных областей применения генераторов – написание «плоского» асинхронного кода.

Общий принцип такой:

Генератор yield'ит не просто значения, а промисы.
Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы – один за другим, и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат – например, возвращает через промис куда-то ещё, во внешний код или просто использует, как в примере ниже.
// генератор для получения и показа аватара
// он yield'ит промисы
function* showUserAvatar() {

  let userFetch = yield fetch('/article/generator/user.json');
  let userInfo = yield userFetch.json();

  let githubFetch = yield fetch(`https://api.github.com/users/${userInfo.name}`);
  let githubUserInfo = yield githubFetch.json();

  let img = new Image();
  img.src = githubUserInfo.avatar_url;
  img.className = "promise-avatar-example";
  document.body.appendChild(img);

  yield new Promise(resolve => setTimeout(resolve, 3000));

  img.remove();

  return img.src;
}

// вспомогательная функция-чернорабочий
// для выполнения промисов из generator
function execute(generator, yieldValue) {

  let next = generator.next(yieldValue);

  if (!next.done) {
    next.value.then(
      result => execute(generator, result),
      err => generator.throw(err)
    );
  } else {
    // обработаем результат return из генератора
    // обычно здесь вызов callback или что-то в этом духе
    alert(next.value);
  }

}

execute( showUserAvatar() );
---------------------------------------------------------------------------------------------------------------------------------------------------
Модули
Было:
AMD – одна из самых древних систем организации модулей, требует лишь наличия клиентской библиотеки, к примеру, require.js, но поддерживается и серверными средствами.
CommonJS – система модулей, встроенная в сервер Node.JS. Требует поддержки на клиентской и серверной стороне.
UMD – система модулей, которая предложена в качестве универсальной. UMD-модули будут работать и в системе AMD и в CommonJS.

в стандарте:
export let one = 1;
let two = 2; export {two};
При помощи ключевого слова as можно указать, что переменная one будет доступна снаружи (экспортирована) под именем once, а two – под именем twice:
export {one as once, two as twice};

export class User {
  constructor(name) {
    this.name = name;
  }
};

export function sayHi() {
  alert("Hello!");
};

// отдельно от объявлений было бы так:
// export {User, sayHi}

import {one, two} from "./nums";

// импорт one под именем item1, а two – под именем item2
import {one as item1, two as item2} from "./nums";

Можно импортировать все значения сразу в виде объекта вызовом import * as obj, например:
import * as numbers from "./nums";

Если поставить после export слово default, то значение станет «экспортом по умолчанию».
Такое значение можно импортировать без фигурных скобок.
---------------------------------------------------------------------------------------------------------------------------------------------------
Прокси (proxy) – особый объект, смысл которого – перехватывать обращения к другому объекту и, при необходимости, модифицировать их
let proxy = new Proxy(target, handler)
target – объект, обращения к которому надо перехватывать.
handler – объект с «ловушками»: функциями-перехватчиками для операций к target
Если для операции нет ловушки, то она выполняется напрямую над target

let user = {};

let proxy = new Proxy(user, {
  get(target, prop) {
    alert(`Чтение ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    alert(`Запись ${prop} ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.firstName = "Ilya"; // запись

proxy.firstName; // чтение

alert(user.firstName); // Ilya

Полный список возможных функций-перехватчиков, которые может задавать handler:

getPrototypeOf – перехватывает обращение к методу getPrototypeOf.
setPrototypeOf – перехватывает обращение к методу setPrototypeOf.
isExtensible – перехватывает обращение к методу isExtensible.
preventExtensions – перехватывает обращение к методу preventExtensions.
getOwnPropertyDescriptor – перехватывает обращение к методу getOwnPropertyDescriptor.
defineProperty – перехватывает обращение к методу defineProperty.
has – перехватывает проверку существования свойства, которая используется в операторе in и в некоторых других методах встроенных объектов.
get – перехватывает чтение свойства.
set – перехватывает запись свойства.
deleteProperty – перехватывает удаление свойства оператором delete.
enumerate – срабатывает при вызове for..in или for..of, возвращает итератор для свойств объекта.
ownKeys – перехватывает обращения к методу getOwnPropertyNames.
apply – перехватывает вызовы target().
construct – перехватывает вызовы new target().
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------




